<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Batching and Timing: How Reagent Renders Changes to Application State</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Reagent</span> <span class="project-version">0.9.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="BatchingAndTiming.html"><div class="inner"><span>Batching and Timing: How Reagent Renders Changes to Application State</span></div></a></li><li class="depth-1 "><a href="CljsjsReactProblems.html"><div class="inner"><span>Question</span></div></a></li><li class="depth-1 "><a href="ComponentNotRerendering.html"><div class="inner"><span>## Question</span></div></a></li><li class="depth-1 "><a href="ControlledInputs.html"><div class="inner"><span>Controlled inputs</span></div></a></li><li class="depth-1 "><a href="CreatingReagentComponents.html"><div class="inner"><span>#### Not An Absolute Introduction</span></div></a></li><li class="depth-1 "><a href="InteropWithReact.html"><div class="inner"><span>Interop with React</span></div></a></li><li class="depth-1 "><a href="ManagingState.html"><div class="inner"><span>Managing state: atoms, cursors, Reactions, and tracking</span></div></a></li><li class="depth-1 "><a href="MyAttributesAreMissing.html"><div class="inner"><span>## Question</span></div></a></li><li class="depth-1 "><a href="README.html"><div class="inner"><span># Tutorials</span></div></a></li><li class="depth-1 "><a href="ReactFeatures.html"><div class="inner"><span>React Features</span></div></a></li><li class="depth-1 "><a href="UsingAnEntity.html"><div class="inner"><span>## Question</span></div></a></li><li class="depth-1 "><a href="UsingHiccupToDescribeHTML.html"><div class="inner"><span>Using Hiccup to Describe HTML</span></div></a></li><li class="depth-1 "><a href="UsingRefs.html"><div class="inner"><span>## Question</span></div></a></li><li class="depth-1 "><a href="UsingSquareBracketsInsteadOfParens.html"><div class="inner"><span># Components</span></div></a></li><li class="depth-1 "><a href="WhenDoComponentsUpdate.html"><div class="inner"><span># Components Are Reactive</span></div></a></li><li class="depth-1 "><a href="dangerouslySetInnerHTML.html"><div class="inner"><span>## Question</span></div></a></li><li class="depth-1 "><a href="development.html"><div class="inner"><span>Reagent development</span></div></a></li><li class="depth-1 "><a href="material-ui.html"><div class="inner"><span>Material-UI</span></div></a></li><li class="depth-1 "><a href="smooth-ui.html"><div class="inner"><span>Smooth UI</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 branch"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span></span></div></div></li><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reagent</span></div></div></li><li class="depth-2 branch"><a href="reagent.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="reagent.debug.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>debug</span></div></a></li><li class="depth-2"><a href="reagent.dom.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dom</span></div></a></li><li class="depth-3"><a href="reagent.dom.server.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>server</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>impl</span></div></div></li><li class="depth-3 branch"><a href="reagent.impl.batching.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>batching</span></div></a></li><li class="depth-3 branch"><a href="reagent.impl.component.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>component</span></div></a></li><li class="depth-3 branch"><a href="reagent.impl.template.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>template</span></div></a></li><li class="depth-3"><a href="reagent.impl.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-2 branch"><a href="reagent.interop.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>interop</span></div></a></li><li class="depth-2"><a href="reagent.ratom.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ratom</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#batching-and-timing-how-reagent-renders-changes-to-application-state" name="batching-and-timing-how-reagent-renders-changes-to-application-state"></a>Batching and Timing: How Reagent Renders Changes to Application State</h1>
<p>Changes in application state (as represented by Reagent’s <code>atom</code>s) are not rendered immediately to the DOM. Instead, Reagent waits until the browser is ready to repaint the window, and then all the changes are rendered in one single go.</p>
<p>This is good for all sorts of reasons:</p>
<ul>
  <li>Reagent doesn’t have to spend time doing renderings that no one would ever see (because changes to application state happened faster than the browser could repaint).</li>
  <li>If two or more atoms are changed simultaneously, this now leads to only one re-rendering, and not two.</li>
  <li>The new code does proper batching of renderings even when changes to atoms are done outside of event handlers (which is great for e.g core.async users).</li>
  <li>Repaints can be synced by the browser with for example CSS transitions, since Reagent uses requestAnimationFrame to do the batching. That makes for example animations smoother.</li>
</ul>
<p>In short, Reagent renders less often, but at the right times. For a much better description of why async rendering is good, see David Nolen’s <a href="http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs">excellent explanation here.</a></p>
<h2><a href="#the-bad-news" name="the-bad-news"></a>The bad news</h2>
<p>Lunches in general tend to be non-free, and this is no exception. The downside to async rendering is that you can no longer depend on changes to atoms being immediately available in the DOM. (Actually, you couldn’t have truly relied upon it anyway because React.js itself does batching inside event handlers.)</p>
<p>The biggest impact is in testing: be sure to call <code>reagent.core/flush</code> to force Reagent to synchronize state with the DOM.</p>
<h2><a href="#an-example" name="an-example"></a>An example</h2>
<p>Here is an example to (hopefully) demonstrate the virtues of async rendering. It consists of a simple color chooser (three sliders to set the red, green and blue components of a base color), and shows the base color + a bunch of divs in random matching colors. As soon as the base color is changed, a new set of random colors is shown.</p>
<p>If you change one of the base color components, the base color should change immediately, and smoothly (on my Macbook Air, rendering takes around 2ms, with 20 colored divs showing).</p>
<p>But perhaps more interesting is to see what happens when the updates can’t be made smoothly (because the browser simply cannot re-render the colored divs quickly enough). On my machine, this starts to happen if I change the number of divs shown to above 150 or so.</p>
<p>As you increase the number of divs, you’ll notice that the base color no longer changes quite so smoothly when you move the color sliders.</p>
<p>But the crucial point is that the sliders <strong>still work</strong>. Without async rendering, you could quickly get into a situation where the browser hangs for a while, doing updates corresponding to an old state.</p>
<p>With async rendering, the only thing that happens is that the frame rate goes down.</p>
<p>Btw, I find it quite impressive that React manages to change 500 divs (12 full screens worth) in slightly more than 40ms. And even better: when I change the number of divs shown, it only takes around 6ms to re-render the color palette (because the individual divs don’t have to be re-rendered, divs are just added or removed from the DOM as needed).</p>
<pre><code class="clojure">(ns example
  (:require [reagent.core :as r]))
(defn timing-wrapper [f]
  (let [start-time (r/atom nil)
        render-time (r/atom nil)
        now #(.now js/Date)
        start #(reset! start-time (now))
        stop #(reset! render-time (- (now) @start-time))
        timed-f (with-meta f
                  {:component-will-mount start
                   :component-will-update start
                   :component-did-mount stop
                   :component-did-update stop})]
    (fn []
      [:div
       [:p [:em "render time: " @render-time "ms"]]
       [timed-f]])))

(def base-color (r/atom {:red 130 :green 160 :blue 120}))
(def ncolors (r/atom 20))
(def random-colors (r/atom nil))

(defn to-rgb [{:keys [red green blue]}]
  (let [hex #(str (if (&lt; % 16) "0")
                  (-&gt; % js/Math.round (.toString 16)))]
    (str "#" (hex red) (hex green) (hex blue))))

(defn tweak-color [{:keys [red green blue]}]
  (let [rnd #(-&gt; (js/Math.random) (* 256))
        tweak #(-&gt; % (+ (rnd)) (/ 2) js/Math.floor)]
    {:red (tweak red) :green (tweak green) :blue (tweak blue)}))

(defn reset-random-colors [color]
  (reset! random-colors
          (repeatedly #(-&gt; color tweak-color to-rgb))))

(defn color-choose [color-part]
  [:div.color-slider
   (name color-part) " " (color-part @base-color)
   [:input {:type "range" :min 0 :max 255
            :value (color-part @base-color)
            :on-change (fn [e]
                         (swap! base-color assoc
                                color-part (-&gt; e .-target .-value int))
                         (reset-random-colors @base-color))}]])

(defn ncolors-choose []
  [:div.color-slider
   "number of color divs " @ncolors
   [:input {:type "range" :min 0 :max 500
            :value @ncolors
            :on-change #(reset! ncolors (-&gt; % .-target .-value int))}]])

(defn color-plate [color]
  [:div.color-plate
   {:style {:background-color color}}])

(defn palette []
  (let [color @base-color
        n @ncolors]
    [:div
     [:p "base color: "]
     [color-plate (to-rgb color)]
     [:div.color-samples
      [:p n " random matching colors:"]
      (map-indexed (fn [k v]
                     ^{:key k} [color-plate v])
                   (take n @random-colors))]]))

(defn color-demo []
  (reset-random-colors @base-color)
  (fn []
    [:div
     [:h2 "Matching colors"]
     [color-choose :red]
     [color-choose :green]
     [color-choose :blue]
     [ncolors-choose]
     [timing-wrapper palette]]))
</code></pre>
<h2><a href="#tapping-into-the-rendering-loop" name="tapping-into-the-rendering-loop"></a>Tapping into the rendering loop</h2>
<p>The <code>next-tick</code> function allows you to tap into the rendering loop. The function passed to <code>next-tick</code> is invoked immediately before the next rendering (which is in turn triggered using <code>requestAnimationFrame</code>).</p>
<p>The <code>after-update</code> is similar: it works just like <code>next-tick</code>, except that the function given is invoked immediately after the next rendering.</p></div></div></div></body></html>